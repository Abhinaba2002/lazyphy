<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chess Game</title>
    <style>
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f0f0;
            font-family: Arial, sans-serif;
            background-color: rgb(38, 37, 37);
        }

        #chessboard {
            display: grid;
            grid-template-columns: repeat(8, 100px);
            grid-template-rows: repeat(8, 100px);
            box-shadow: 0.1px 0.1px 2px rgba(0, 0, 0, 0.3);
        }

        .cell {
            width: 100px;
            height: 100px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 5.5rem; /* Increased size */
            position: relative;
        }

        .black {
            background-color: #749c4b;
        }

        .white {
            background-color: #f2f2e3;
        }

        .cell.selected {
            background-color: rgb(233, 243, 91);
        }

        .cell.valid-move::before {
            content: '';
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: rgba(36, 33, 33, 0.5);
            position: absolute;
        }

        .piece {
            cursor: grab;
        }

        .piece.dragging {
            opacity: 0.5;
            cursor: grabbing;
        }
    </style>
</head>
<body>
    <div id="chessboard"></div>

    <script>
        const chessboard = document.getElementById('chessboard');

        const pieces = {
            pawn: '♙',
            rook: '♖',
            knight: '♘',
            bishop: '♗',
            queen: '♕',
            king: '♔',
            blackPawn: '♟',
            blackRook: '♜',
            blackKnight: '♞',
            blackBishop: '♝',
            blackQueen: '♛',
            blackKing: '♚'
        };


        const initialBoard = [
            [pieces.blackRook, pieces.blackKnight, pieces.blackBishop, pieces.blackQueen, pieces.blackKing, pieces.blackBishop, pieces.blackKnight, pieces.blackRook],
            [pieces.blackPawn, pieces.blackPawn, pieces.blackPawn, pieces.blackPawn, pieces.blackPawn, pieces.blackPawn, pieces.blackPawn, pieces.blackPawn],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            ['', '', '', '', '', '', '', ''],
            [pieces.pawn, pieces.pawn, pieces.pawn, pieces.pawn, pieces.pawn, pieces.pawn, pieces.pawn, pieces.pawn],
            [pieces.rook, pieces.knight, pieces.bishop, pieces.queen, pieces.king, pieces.bishop, pieces.knight, pieces.rook]
        ];

        let selectedPiece = null;
        let sourceCell = null;
        let isWhiteTurn = false; // Black starts

        function createBoard() {
            for (let row = 0; row < 8; row++) {
                for (let col = 0; col < 8; col++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.classList.add((row + col) % 2 === 0 ? 'white' : 'black');
                    cell.dataset.row = row;
                    cell.dataset.col = col;

                    const piece = initialBoard[row][col];
                    if (piece) {
                        const pieceElement = document.createElement('div');
                        pieceElement.textContent = piece;
                        pieceElement.classList.add('piece');
                        pieceElement.draggable = true;
                        pieceElement.dataset.piece = piece;
                        pieceElement.dataset.color = piece === piece.toUpperCase() ? 'white' : 'black';
                        cell.appendChild(pieceElement);
                    }

                    cell.addEventListener('click', handleCellClick);
                    chessboard.appendChild(cell);
                }
            }
        }

        function isPathClear(sourceRow, sourceCol, targetRow, targetCol) {
            const rowDirection = Math.sign(targetRow - sourceRow);
            const colDirection = Math.sign(targetCol - sourceCol);

            let currentRow = sourceRow + rowDirection;
            let currentCol = sourceCol + colDirection;

            while (currentRow !== targetRow || currentCol !== targetCol) {
                const cell = document.querySelector(`.cell[data-row='${currentRow}'][data-col='${currentCol}']`);
                if (cell && cell.firstChild) {
                    return false; // Path is blocked
                }

                currentRow += rowDirection;
                currentCol += colDirection;
            }

            return true; // Path is clear
        }

        function isValidMove(piece, sourceRow, sourceCol, targetRow, targetCol, targetPiece) {
            const rowDiff = Math.abs(targetRow - sourceRow);
            const colDiff = Math.abs(targetCol - sourceCol);

            // Prevent capturing the same color
            if (targetPiece && targetPiece.dataset.color === selectedPiece.dataset.color) {
                return false;
            }

            switch (piece) {
                case pieces.pawn:
                    return targetRow - sourceRow === -1 && colDiff === 0 && !targetPiece;
                case pieces.blackPawn:
                    return targetRow - sourceRow === 1 && colDiff === 0 && !targetPiece;
                case pieces.rook:
                case pieces.blackRook:
                    return (rowDiff === 0 || colDiff === 0) && isPathClear(sourceRow, sourceCol, targetRow, targetCol);
                case pieces.knight:
                case pieces.blackKnight:
                    return (rowDiff === 2 && colDiff === 1) || (rowDiff === 1 && colDiff === 2);
                case pieces.bishop:
                case pieces.blackBishop:
                    return rowDiff === colDiff && isPathClear(sourceRow, sourceCol, targetRow, targetCol);
                case pieces.queen:
                case pieces.blackQueen:
                    return (rowDiff === colDiff || rowDiff === 0 || colDiff === 0) && isPathClear(sourceRow, sourceCol, targetRow, targetCol);
                case pieces.king:
                case pieces.blackKing:
                    return rowDiff <= 1 && colDiff <= 1;
                default:
                    return false;
            }
        }

        function showValidMoves(piece, sourceRow, sourceCol) {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const targetRow = parseInt(cell.dataset.row);
                const targetCol = parseInt(cell.dataset.col);
                const targetPiece = cell.firstChild;

                if (isValidMove(piece, sourceRow, sourceCol, targetRow, targetCol, targetPiece)) {
                    cell.classList.add('valid-move');
                }
            });
        }

        function clearHighlights() {
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                cell.classList.remove('valid-move', 'selected');
            });
        }

        function handleCellClick(event) {
            const cell = event.target.closest('.cell');
            if (!cell) return;

            const piece = cell.firstChild;

            // Deselect current piece and select another
            if (piece && (!selectedPiece || piece.dataset.color === (isWhiteTurn ? 'white' : 'black') || piece.dataset.color === (isWhiteTurn ? 'black' : 'white'))) {
                clearHighlights();
                selectedPiece = piece;
                sourceCell = cell;
                cell.classList.add('selected');

                const sourceRow = parseInt(cell.dataset.row);
                const sourceCol = parseInt(cell.dataset.col);

                showValidMoves(piece.dataset.piece, sourceRow, sourceCol);
            } else if (selectedPiece) {
                // Attempt to move selected piece
                const sourceRow = parseInt(sourceCell.dataset.row);
                const sourceCol = parseInt(sourceCell.dataset.col);
                const targetRow = parseInt(cell.dataset.row);
                const targetCol = parseInt(cell.dataset.col);
                const targetPiece = cell.firstChild;

                if (isValidMove(selectedPiece.dataset.piece, sourceRow, sourceCol, targetRow, targetCol, targetPiece)) {
                    // Move the piece

                    const pieceText = sourceCell.firstChild.textContent;
                    const isBlack = initialBoard[0].includes(pieceText) || initialBoard[1].includes(pieceText);
            
            

                    if (isWhiteTurn ==isBlack){
                    cell.appendChild(selectedPiece);
                    clearHighlights();

                    // Switch turn
                    isWhiteTurn = !isWhiteTurn;
                    
                    // Deselect the piece
                    selectedPiece = null;
                    sourceCell = null;
                    }
                } else {
                    // Invalid move, deselect piece
                    clearHighlights();
                    selectedPiece = null;
                    sourceCell = null;
                }
            }
        }

        createBoard();
    </script>
</body>
</html>

